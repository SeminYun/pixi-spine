{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/FlipXTimeline.js","src/SpineRuntime/FlipYTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/SkinnedMeshAttachment.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","spine","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders",2,"Animation","name","timelines","duration","this","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil",3,"TrackEntry","AnimationState","stateData","timeScales","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","getCurrent","./TrackEntry",4,"AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty",5,"AtlasReader","AtlasPage","AtlasRegion","Atlas","atlasText","baseUrl","crossOrigin","lastIndexOf","pages","regions","texturesLoading","resolution","utils","getResolutionOfUrl","reader","tuple","page","line","readLine","trim","region","rotate","readValue","readTuple","x","parseInt","y","width","height","v","u2","v2","abs","splits","pads","originalWidth","originalHeight","offsetX","offsetY","console","log","format","Format","minFilter","TextureFilter","magFilter","direction","uWrap","TextureWrap","clampToEdge","vWrap","repeat","rendererObject","BaseTexture","fromImage","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","./AtlasPage","./AtlasReader","./AtlasRegion",6,"RegionAttachment","MeshAttachment","SkinnedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","regionOffsetX","regionOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","regionU","regionV","regionU2","regionV2","regionRotate","newSkinnedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./SkinnedMeshAttachment",7,8,"text","lines","split","value","replace","colon","indexOf","substring","lastMatch","comma","substr",9,10,"Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves",11,"AttachmentType","boundingbox","mesh","skinnedmesh",12,"Bone","boneData","parent","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","flipX","flipY","m00","m01","worldX","m10","m11","worldY","worldRotation","worldScaleX","worldScaleY","worldFlipX","worldFlipY","updateWorldTransform","inheritScale","inheritRotation","skeletonFlipX","skeletonFlipY","radians","degRad","cos","sin","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY",13,"BoneData",14,"vertices","type","computeWorldVertices","bone","worldVertices","px","py","./AttachmentType",15,"ColorTimeline","g","b","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot",16,"setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY",17,"DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex",18,"Event","intValue","floatValue","stringValue",19,"EventData",20,"EventTimeline","frame",21,"FfdTimeline","frameVertices","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev",22,"FlipXTimeline","boneIndex","flip","bones",23,"FlipYTimeline",24,"IkConstraint","bendDirection","findBone","apply1","apply2","targetX","targetY","parentRotation","radDeg","atan2","child","childRotation","positionX","positionY","tempPosition","temp","parentParent","childX","childY","offset","len1","sqrt","len2","cosDenom","childAngle","acos","adjacent","opposite","parentAngle",25,"IkConstraintData",26,"IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix",27,"uvs","regionUVs","triangles","hullLength","edges","Float32Array","verticesCount","vx","vy",28,"updateOffset","regionScaleX","regionScaleY","localX2","localY2","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices",29,"RotateTimeline","angle","amount","prevFrameValue",30,"ScaleTimeline","prevFrameX","prevFrameY",31,"Slot","Skeleton","slotData","boneCache","updateCache","ikConstraintsCount","arrayCount","nonIkBones","outer","cacheBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","ikConstraintName","./Bone","./IkConstraint","./Slot",32,"SkeletonBounds","polygonPool","polygons","boundingBoxes","minX","minY","maxX","maxY","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","x1","y1","x2","y2","m","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","../SpineRuntime",33,"SkeletonData","skins","animations","version","hash","findEvent","eventName",34,"SlotData","Skin","TranslateTimeline","SkeletonJsonParser","attachmentLoader","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","BLEND_MODES","ADD","NORMAL","skinMap","slotEntry","readAttachment","addAttachment","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","field","ffd","meshMap","meshName","isMesh","verticesValue","j","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./FlipXTimeline","./FlipYTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./SkeletonData","./Skin","./SlotData","./TranslateTimeline",35,"attachments","oldSkin",36,"wx","wy","weight","skeletonBones","w",37,"_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas",38,"multiply","MULTIPLY","screen","SCREEN","additive","normal",39,40,41,"./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js",42,"PI",43,"spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","hitArea","Rectangle","clickArea","runLowerAnimation","shoot_slot","anis","ani","play","createTextureByRegion","spriteRect","trimmed","crop","spriteSourceSizeHeight","clone","base_texture","Texture","atlasParser","fromAtlas","resourceName","AnimCache","Object","create","constructor","setTimeScale","aniName","speed","undefined","getCurrentAnimationName","defineProperties","get","updateTransform","autoUpdateTransform","set","dt","preProcessing","children","visible","sprites","position","tint","rgb2hex","meshes","JLib","getRectFromPoly","Date","now","timeDelta","spriteTexture","descriptor","Sprite","anchor","baseTexture","texture","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","../loaders/atlasParser",44,"Loader","addPixiMiddleware","loader","use","./atlasParser",45,"Resource","async","resource","isJson","atlasPath","url","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","add","res","spineAtlas","xhr","responseText","spineJsonParser","enableCaching","each","done","hasLoaded","once",46,"./Loader"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = {\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n\n},{\"./Spine\":43,\"./SpineRuntime\":41,\"./loaders\":46}],2:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n\n},{\"../SpineUtil\":42}],3:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.TrackEntry = require('./TrackEntry');\nspine.AnimationState = function (stateData)\n{\n    //seminz\n    this.timeScales = {};\n    //end seminz\n    this.data = stateData;\n    this.tracks = [];\n    this.events = [];\n};\nspine.AnimationState.prototype = {\n    onStart: null,\n    onEnd: null,\n    onComplete: null,\n    onEvent: null,\n    timeScale: 1,\n    update: function (delta)\n    {\n        delta *= this.timeScale;\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            current.time += delta * current.timeScale;\n            if (current.previous)\n            {\n                var previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n\n            var next = current.next;\n            if (next)\n            {\n                next.time = current.lastTime - next.delay;\n                if (next.time >= 0) this.setCurrent(i, next);\n            } else {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\n            }\n        }\n    },\n    apply: function (skeleton)\n    {\n        skeleton.resetDrawOrder();\n\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            this.events.length = 0;\n\n            var time = current.time;\n            var lastTime = current.lastTime;\n            var endTime = current.endTime;\n            var loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            var previous = current.previous;\n            if (!previous)\n            {\n                if (current.mix == 1)\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\n                else\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\n            } else {\n                var previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                var alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1)\n                {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\n            }\n\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\n            {\n                var event = this.events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\n            {\n                var count = Math.floor(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    },\n    clearTracks: function ()\n    {\n        for (var i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    },\n    clearTrack: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (!current) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n    },\n    _expandToIndex: function (index)\n    {\n        if (index < this.tracks.length) return this.tracks[index];\n        while (index >= this.tracks.length)\n            this.tracks.push(null);\n        return null;\n    },\n    setCurrent: function (index, entry)\n    {\n        var current = this._expandToIndex(index);\n        if (current)\n        {\n            var previous = current.previous;\n            current.previous = null;\n\n            if (current.onEnd) current.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0)\n            {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous && current.mixTime / current.mixDuration < 0.5)\n                    entry.previous = previous;\n                else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    },\n    setAnimationByName: function (trackIndex, animationName, loop)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.setAnimation(trackIndex, animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimation: function (trackIndex, animation, loop)\n    {\n        //seminz\n        this.timeScale = this.timeScales[animation.name];\n        //end seminz\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    },\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.addAnimation(trackIndex, animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (trackIndex, animation, loop, delay)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        var last = this._expandToIndex(trackIndex);\n        if (last)\n        {\n            while (last.next)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0)\n        {\n            if (last)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    },\n    /** May be null. */\n    getCurrent: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n};\nmodule.exports = spine.AnimationState;\n\n\n},{\"../SpineUtil\":42,\"./TrackEntry\":39}],4:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n\n},{\"../SpineUtil\":42}],5:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\n\r\nspine.Atlas = function (atlasText, baseUrl, crossOrigin)\r\n{\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n\r\n    this.pages = [];\r\n    this.regions = [];\r\n\r\n    this.texturesLoading = 0;\r\n\r\n    var self = this;\r\n    var resolution = PIXI.utils.getResolutionOfUrl(baseUrl);\r\n\r\n    var reader = new spine.AtlasReader(atlasText);\r\n    var tuple = [];\r\n    tuple.length = 4;\r\n    var page = null;\r\n    while (true)\r\n    {\r\n        var line = reader.readLine();\r\n        if (line === null) break;\r\n        line = reader.trim(line);\r\n        if (!line.length)\r\n            page = null;\r\n        else if (!page)\r\n        {\r\n            page = new spine.AtlasPage();\r\n            page.name = line;\r\n\r\n            if (reader.readTuple(tuple) == 2)\r\n            { // size is only optional for an atlas packed with an old TexturePacker.\r\n                page.width = parseInt(tuple[0]);\r\n                page.height = parseInt(tuple[1]);\r\n                reader.readTuple(tuple);\r\n            } else {\r\n                //and I dont want to add support of old format for meshes! we need UVs NOW!\r\n                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n            }\r\n            page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n            reader.readTuple(tuple);\r\n            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n            var direction = reader.readValue();\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            if (direction == \"x\")\r\n                page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"y\")\r\n                page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"xy\")\r\n                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n            page.rendererObject = PIXI.BaseTexture.fromImage(baseUrl + line, crossOrigin);\r\n\r\n            this.pages.push(page);\r\n\r\n        } else {\r\n            var region = new spine.AtlasRegion();\r\n            region.name = line;\r\n            region.page = page;\r\n\r\n            region.rotate = reader.readValue() == \"true\";\r\n\r\n            reader.readTuple(tuple);\r\n            var x = parseInt(tuple[0]);\r\n            var y = parseInt(tuple[1]);\r\n\r\n            reader.readTuple(tuple);\r\n            var width = parseInt(tuple[0]);\r\n            var height = parseInt(tuple[1]);\r\n\r\n            region.u = x / page.width;\r\n            region.v = y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (x + height) / page.width;\r\n                region.v2 = (y + width) / page.height;\r\n            } else {\r\n                region.u2 = (x + width) / page.width;\r\n                region.v2 = (y + height) / page.height;\r\n            }\r\n            region.x = x / resolution;\r\n            region.y = y / resolution;\r\n            region.width = Math.abs(width) / resolution;\r\n            region.height = Math.abs(height) / resolution;\r\n\r\n            if (reader.readTuple(tuple) == 4)\r\n            { // split is optional\r\n                region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                if (reader.readTuple(tuple) == 4)\r\n                { // pad is optional, but only present with splits\r\n                    region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                    reader.readTuple(tuple);\r\n                }\r\n            }\r\n\r\n            region.originalWidth = parseInt(tuple[0]) / resolution;\r\n            region.originalHeight = parseInt(tuple[1]) / resolution;\r\n\r\n            reader.readTuple(tuple);\r\n            region.offsetX = parseInt(tuple[0]) / resolution;\r\n            region.offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n            region.index = parseInt(reader.readValue());\r\n\r\n            this.regions.push(region);\r\n        }\r\n    }\r\n};\r\nspine.Atlas.prototype = {\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.u = region.x / page.width;\r\n            region.v = region.y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (region.x + region.height) / page.width;\r\n                region.v2 = (region.y + region.width) / page.height;\r\n            } else {\r\n                region.u2 = (region.x + region.width) / page.width;\r\n                region.v2 = (region.y + region.height) / page.height;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n\n},{\"../SpineUtil\":42,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9}],6:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.AtlasAttachmentParser = function (atlas)\r\n{\r\n    this.atlas = atlas;\r\n};\r\nspine.AtlasAttachmentParser.prototype = {\r\n    newRegionAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\r\n        var attachment = new spine.RegionAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.MeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newSkinnedMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.SkinnedMeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newBoundingBoxAttachment: function (skin, name)\r\n    {\r\n        return new spine.BoundingBoxAttachment(name);\r\n    }\r\n};\r\nmodule.exports = spine.AtlasAttachmentParser;\r\n\r\n\n},{\"../SpineUtil\":42,\"./BoundingBoxAttachment\":14,\"./MeshAttachment\":27,\"./RegionAttachment\":28,\"./SkinnedMeshAttachment\":36}],7:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n\n},{\"../SpineUtil\":42}],8:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n\n},{\"../SpineUtil\":42}],9:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    page: null,\r\n    name: null,\r\n    x: 0, y: 0,\r\n    width: 0, height: 0,\r\n    u: 0, v: 0, u2: 0, v2: 0,\r\n    offsetX: 0, offsetY: 0,\r\n    originalWidth: 0, originalHeight: 0,\r\n    index: 0,\r\n    rotate: false,\r\n    splits: null,\r\n    pads: null\r\n};\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n\n},{\"../SpineUtil\":42}],10:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],11:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = {\r\n    region: 0,\r\n    boundingbox: 1,\r\n    mesh: 2,\r\n    skinnedmesh: 3\r\n};\r\nmodule.exports = spine.AttachmentType;\r\n\r\n\n},{\"../SpineUtil\":42}],12:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Bone = function (boneData, skeleton, parent)\r\n{\r\n    this.data = boneData;\r\n    this.skeleton = skeleton;\r\n    this.parent = parent;\r\n    this.setToSetupPose();\r\n};\r\nspine.Bone.yDown = false;\r\nspine.Bone.prototype = {\r\n    x: 0, y: 0,\r\n    rotation: 0, rotationIK: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    flipX: false, flipY: false,\r\n    m00: 0, m01: 0, worldX: 0, // a b x\r\n    m10: 0, m11: 0, worldY: 0, // c d y\r\n    worldRotation: 0,\r\n    worldScaleX: 1, worldScaleY: 1,\r\n    worldFlipX: false, worldFlipY: false,\r\n    updateWorldTransform: function ()\r\n    {\r\n        var parent = this.parent;\r\n        if (parent)\r\n        {\r\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\r\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\r\n            if (this.data.inheritScale)\r\n            {\r\n                this.worldScaleX = parent.worldScaleX * this.scaleX;\r\n                this.worldScaleY = parent.worldScaleY * this.scaleY;\r\n            } else {\r\n                this.worldScaleX = this.scaleX;\r\n                this.worldScaleY = this.scaleY;\r\n            }\r\n            this.worldRotation = this.data.inheritRotation ? (parent.worldRotation + this.rotationIK) : this.rotationIK;\r\n            this.worldFlipX = parent.worldFlipX != this.flipX;\r\n            this.worldFlipY = parent.worldFlipY != this.flipY;\r\n        } else {\r\n            var skeletonFlipX = this.skeleton.flipX, skeletonFlipY = this.skeleton.flipY;\r\n            this.worldX = skeletonFlipX ? -this.x : this.x;\r\n            this.worldY = (skeletonFlipY != spine.Bone.yDown) ? -this.y : this.y;\r\n            this.worldScaleX = this.scaleX;\r\n            this.worldScaleY = this.scaleY;\r\n            this.worldRotation = this.rotationIK;\r\n            this.worldFlipX = skeletonFlipX != this.flipX;\r\n            this.worldFlipY = skeletonFlipY != this.flipY;\r\n        }\r\n        var radians = this.worldRotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        if (this.worldFlipX)\r\n        {\r\n            this.m00 = -cos * this.worldScaleX;\r\n            this.m01 = sin * this.worldScaleY;\r\n        } else {\r\n            this.m00 = cos * this.worldScaleX;\r\n            this.m01 = -sin * this.worldScaleY;\r\n        }\r\n        if (this.worldFlipY != spine.Bone.yDown)\r\n        {\r\n            this.m10 = -sin * this.worldScaleX;\r\n            this.m11 = -cos * this.worldScaleY;\r\n        } else {\r\n            this.m10 = sin * this.worldScaleX;\r\n            this.m11 = cos * this.worldScaleY;\r\n        }\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.rotationIK = this.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.flipX = data.flipX;\r\n        this.flipY = data.flipY;\r\n    },\r\n    worldToLocal: function (world)\r\n    {\r\n        var dx = world[0] - this.worldX, dy = world[1] - this.worldY;\r\n        var m00 = this.m00, m10 = this.m10, m01 = this.m01, m11 = this.m11;\r\n        if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown))\r\n        {\r\n            m00 = -m00;\r\n            m11 = -m11;\r\n        }\r\n        var invDet = 1 / (m00 * m11 - m01 * m10);\r\n        world[0] = dx * m00 * invDet - dy * m01 * invDet;\r\n        world[1] = dy * m11 * invDet - dx * m10 * invDet;\r\n    },\r\n    localToWorld: function (local)\r\n    {\r\n        var localX = local[0], localY = local[1];\r\n        local[0] = localX * this.m00 + localY * this.m01 + this.worldX;\r\n        local[1] = localX * this.m10 + localY * this.m11 + this.worldY;\r\n    }\r\n};\r\nmodule.exports = spine.Bone;\r\n\r\n\n},{\"../SpineUtil\":42}],13:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.BoneData = function (name, parent)\r\n{\r\n    this.name = name;\r\n    this.parent = parent;\r\n};\r\nspine.BoneData.prototype = {\r\n    length: 0,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    inheritScale: true,\r\n    inheritRotation: true,\r\n    flipX: false, flipY: false\r\n};\r\nmodule.exports = spine.BoneData;\r\n\r\n\n},{\"../SpineUtil\":42}],14:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n\n},{\"../SpineUtil\":42,\"./AttachmentType\":11}],15:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],16:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n\n},{\"../SpineUtil\":42}],17:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2}],18:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n\n},{\"../SpineUtil\":42}],19:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n\n},{\"../SpineUtil\":42}],20:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2}],21:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (slot.attachment != this.attachment) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],22:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipXTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipXTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipX = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipXTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],23:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipYTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipYTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipY = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipYTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],24:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.IkConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.mix = data.mix;\r\n    this.bendDirection = data.bendDirection;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = data.bones.length; i < n; i++)\r\n        this.bones.push(skeleton.findBone(data.bones[i].name));\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\nspine.IkConstraint.prototype = {\r\n    apply: function ()\r\n    {\r\n        var target = this.target;\r\n        var bones = this.bones;\r\n        switch (bones.length)\r\n        {\r\n        case 1:\r\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n};\r\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n * coordinate system. */\r\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\r\n{\r\n    var parentRotation = (!bone.data.inheritRotation || !bone.parent) ? 0 : bone.parent.worldRotation;\r\n    var rotation = bone.rotation;\r\n    // worldY and targetY sign depends on global constant spine.Bone.yDown\r\n    var rotationIK = (spine.Bone.yDown?-spine.radDeg:spine.radDeg)* Math.atan2(targetY - bone.worldY, targetX - bone.worldX) - parentRotation;\r\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\r\n};\r\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n * target is specified in the world coordinate system.\r\n * @param child Any descendant bone of the parent. */\r\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDirection, alpha)\r\n{\r\n    var childRotation = child.rotation, parentRotation = parent.rotation;\r\n    if (!alpha)\r\n    {\r\n        child.rotationIK = childRotation;\r\n        parent.rotationIK = parentRotation;\r\n        return;\r\n    }\r\n    var positionX, positionY, tempPosition = spine.temp;\r\n    var parentParent = parent.parent;\r\n    if (parentParent)\r\n    {\r\n        tempPosition[0] = targetX;\r\n        tempPosition[1] = targetY;\r\n        parentParent.worldToLocal(tempPosition);\r\n        targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;\r\n        targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;\r\n    } else {\r\n        targetX -= parent.x;\r\n        targetY -= parent.y;\r\n    }\r\n    if (child.parent == parent)\r\n    {\r\n        positionX = child.x;\r\n        positionY = child.y;\r\n    } else {\r\n        tempPosition[0] = child.x;\r\n        tempPosition[1] = child.y;\r\n        child.parent.localToWorld(tempPosition);\r\n        parent.worldToLocal(tempPosition);\r\n        positionX = tempPosition[0];\r\n        positionY = tempPosition[1];\r\n    }\r\n    var childX = positionX * parent.worldScaleX, childY = positionY * parent.worldScaleY;\r\n    var offset = Math.atan2(childY, childX);\r\n    var len1 = Math.sqrt(childX * childX + childY * childY), len2 = child.data.length * child.worldScaleX;\r\n    // Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/\r\n    var cosDenom = 2 * len1 * len2;\r\n    if (cosDenom < 0.0001)\r\n    {\r\n        child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;\r\n        return;\r\n    }\r\n    var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;\r\n    if (cos < -1)\r\n        cos = -1;\r\n    else if (cos > 1)\r\n        cos = 1;\r\n    var childAngle = Math.acos(cos) * bendDirection;\r\n    var adjacent = len1 + len2 * cos, opposite = len2 * Math.sin(childAngle);\r\n    var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);\r\n    var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    parent.rotationIK = parentRotation + rotation * alpha;\r\n    rotation = (childAngle + offset) * spine.radDeg - childRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;\r\n};\r\nmodule.exports = spine.IkConstraint;\r\n\r\n\n},{\"../SpineUtil\":42}],25:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n\n},{\"../SpineUtil\":42}],26:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],27:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.MeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.MeshAttachment.prototype = {\r\n    type: spine.AttachmentType.mesh,\r\n    vertices: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function ()\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var bone = slot.bone;\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        var verticesCount = vertices.length;\r\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\r\n        for (var i = 0; i < verticesCount; i += 2)\r\n        {\r\n            var vx = vertices[i];\r\n            var vy = vertices[i + 1];\r\n            worldVertices[i] = vx * m00 + vy * m01 + x;\r\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.MeshAttachment;\r\n\r\n\n},{\"../SpineUtil\":42,\"./AttachmentType\":11}],28:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.RegionAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.offset = [];\r\n    this.offset.length = 8;\r\n    this.uvs = [];\r\n    this.uvs.length = 8;\r\n};\r\nspine.RegionAttachment.prototype = {\r\n    type: spine.AttachmentType.region,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    width: 0, height: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    setUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var uvs = this.uvs;\r\n        if (rotate)\r\n        {\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v2;\r\n            uvs[4/*X3*/] = u;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v;\r\n            uvs[0/*X1*/] = u2;\r\n            uvs[1/*Y1*/] = v2;\r\n        } else {\r\n            uvs[0/*X1*/] = u;\r\n            uvs[1/*Y1*/] = v2;\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v;\r\n            uvs[4/*X3*/] = u2;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v2;\r\n        }\r\n    },\r\n    updateOffset: function ()\r\n    {\r\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\r\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\r\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\r\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\r\n        var localX2 = localX + this.regionWidth * regionScaleX;\r\n        var localY2 = localY + this.regionHeight * regionScaleY;\r\n        var radians = this.rotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        var localXCos = localX * cos + this.x;\r\n        var localXSin = localX * sin;\r\n        var localYCos = localY * cos + this.y;\r\n        var localYSin = localY * sin;\r\n        var localX2Cos = localX2 * cos + this.x;\r\n        var localX2Sin = localX2 * sin;\r\n        var localY2Cos = localY2 * cos + this.y;\r\n        var localY2Sin = localY2 * sin;\r\n        var offset = this.offset;\r\n        offset[0/*X1*/] = localXCos - localYSin;\r\n        offset[1/*Y1*/] = localYCos + localXSin;\r\n        offset[2/*X2*/] = localXCos - localY2Sin;\r\n        offset[3/*Y2*/] = localY2Cos + localXSin;\r\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\r\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\r\n        offset[6/*X4*/] = localX2Cos - localYSin;\r\n        offset[7/*Y4*/] = localYCos + localX2Sin;\r\n    },\r\n    computeVertices: function (x, y, bone, vertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var offset = this.offset;\r\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\r\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\r\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\r\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\r\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\r\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\r\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\r\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\r\n    }\r\n};\r\nmodule.exports = spine.RegionAttachment;\r\n\r\n\n},{\"../SpineUtil\":42,\"./AttachmentType\":11}],29:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],30:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],31:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Bone = require('./Bone');\r\nspine.Slot = require('./Slot');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.Skeleton = function (skeletonData)\r\n{\r\n    this.data = skeletonData;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\r\n    {\r\n        var boneData = skeletonData.bones[i];\r\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\r\n        this.bones.push(new spine.Bone(boneData, this, parent));\r\n    }\r\n\r\n    this.slots = [];\r\n    this.drawOrder = [];\r\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\r\n    {\r\n        var slotData = skeletonData.slots[i];\r\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\r\n        var slot = new spine.Slot(slotData, bone);\r\n        this.slots.push(slot);\r\n        this.drawOrder.push(i);\r\n    }\r\n\r\n    this.ikConstraints = [];\r\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\r\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\r\n\r\n    this.boneCache = [];\r\n    this.updateCache();\r\n};\r\nspine.Skeleton.prototype = {\r\n    x: 0, y: 0,\r\n    skin: null,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    time: 0,\r\n    flipX: false, flipY: false,\r\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\r\n    updateCache: function ()\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        var ikConstraintsCount = ikConstraints.length;\r\n\r\n        var arrayCount = ikConstraintsCount + 1;\r\n        var boneCache = this.boneCache;\r\n        if (boneCache.length > arrayCount) boneCache.length = arrayCount;\r\n        for (var i = 0, n = boneCache.length; i < n; i++)\r\n            boneCache[i].length = 0;\r\n        while (boneCache.length < arrayCount)\r\n            boneCache[boneCache.length] = [];\r\n\r\n        var nonIkBones = boneCache[0];\r\n        var bones = this.bones;\r\n\r\n        outer:\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            var current = bone;\r\n            do {\r\n                for (var ii = 0; ii < ikConstraintsCount; ii++)\r\n                {\r\n                    var ikConstraint = ikConstraints[ii];\r\n                    var parent = ikConstraint.bones[0];\r\n                    var child= ikConstraint.bones[ikConstraint.bones.length - 1];\r\n                    while (true)\r\n                    {\r\n                        if (current == child)\r\n                        {\r\n                            boneCache[ii].push(bone);\r\n                            boneCache[ii + 1].push(bone);\r\n                            continue outer;\r\n                        }\r\n                        if (child == parent) break;\r\n                        child = child.parent;\r\n                    }\r\n                }\r\n                current = current.parent;\r\n            } while (current);\r\n            nonIkBones[nonIkBones.length] = bone;\r\n        }\r\n    },\r\n    /** Updates the world transform for each bone. */\r\n    updateWorldTransform: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            bone.rotationIK = bone.rotation;\r\n        }\r\n        var i = 0, last = this.boneCache.length - 1;\r\n        while (true)\r\n        {\r\n            var cacheBones = this.boneCache[i];\r\n            for (var ii = 0, nn = cacheBones.length; ii < nn; ii++)\r\n                cacheBones[ii].updateWorldTransform();\r\n            if (i == last) break;\r\n            this.ikConstraints[i].apply();\r\n            i++;\r\n        }\r\n    },\r\n    /** Sets the bones and slots to their setup pose values. */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    },\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n        {\r\n            var ikConstraint = ikConstraints[i];\r\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\r\n            ikConstraint.mix = ikConstraint.data.mix;\r\n        }\r\n    },\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            slots[i].setToSetupPose(i);\r\n        }\r\n\r\n        this.resetDrawOrder();\r\n    },\r\n    /** @return May return null. */\r\n    getRootBone: function ()\r\n    {\r\n        return this.bones.length ? this.bones[0] : null;\r\n    },\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return slots[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    },\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skin = this.data.findSkin(skinName);\r\n        if (!skin) throw \"Skin not found: \" + skinName;\r\n        this.setSkin(skin);\r\n    },\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin: function (newSkin)\r\n    {\r\n        if (newSkin)\r\n        {\r\n            if (this.skin)\r\n                newSkin._attachAll(this, this.skin);\r\n            else\r\n            {\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                {\r\n                    var slot = slots[i];\r\n                    var name = slot.data.attachmentName;\r\n                    if (name)\r\n                    {\r\n                        var attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotName: function (slotName, attachmentName)\r\n    {\r\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\r\n    {\r\n        if (this.skin)\r\n        {\r\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    },\r\n    /** @param attachmentName May be null. */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slot = slots[i];\r\n            if (slot.data.name == slotName)\r\n            {\r\n                var attachment = null;\r\n                if (attachmentName)\r\n                {\r\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\r\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw \"Slot not found: \" + slotName;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (ikConstraintName)\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n            if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];\r\n        return null;\r\n    },\r\n    update: function (delta)\r\n    {\r\n        this.time += delta;\r\n    },\r\n    resetDrawOrder: function () {\r\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\r\n        {\r\n            this.drawOrder[i] = i;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skeleton;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Bone\":12,\"./IkConstraint\":24,\"./Slot\":37}],32:[function(require,module,exports){\nvar spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n\n},{\"../SpineRuntime\":41,\"./AttachmentType\":11}],33:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SkeletonData = function ()\r\n{\r\n    this.bones = [];\r\n    this.slots = [];\r\n    this.skins = [];\r\n    this.events = [];\r\n    this.animations = [];\r\n    this.ikConstraints = [];\r\n};\r\nspine.SkeletonData.prototype = {\r\n    name: null,\r\n    defaultSkin: null,\r\n    width: 0, height: 0,\r\n    version: null, hash: null,\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            if (slots[i].name == slotName) return this.slots[i];\r\n        }\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSkin: function (skinName)\r\n    {\r\n        var skins = this.skins;\r\n        for (var i = 0, n = skins.length; i < n; i++)\r\n            if (skins[i].name == skinName) return skins[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findEvent: function (eventName)\r\n    {\r\n        var events = this.events;\r\n        for (var i = 0, n = events.length; i < n; i++)\r\n            if (events[i].name == eventName) return events[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findAnimation: function (animationName)\r\n    {\r\n        var animations = this.animations;\r\n        for (var i = 0, n = animations.length; i < n; i++)\r\n            if (animations[i].name == animationName) return animations[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (ikConstraintName)\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n            if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];\r\n        return null;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonData;\r\n\r\n\n},{\"../SpineUtil\":42}],34:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.FlipXTimeline = require('./FlipXTimeline');\nspine.FlipYTimeline = require('./FlipYTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    this.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw \"IK bone not found: \" + bones[ii];\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw \"Target bone not found: \" + ikMap[\"target\"];\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n            //seminz\n            if(!slotData.blendMode) slotData.blendMode = slotMap[\"additive\"]?PIXI.BLEND_MODES.ADD:PIXI.BLEND_MODES.NORMAL;\n            //end seminz\n\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.mesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.skinnedmesh)\n        {\n            var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n\n            var uvs = this.getFloatArray(map, \"uvs\", 1);\n            var vertices = this.getFloatArray(map, \"vertices\", 1);\n            var weights = [];\n            var bones = [];\n            for (var i = 0, n = vertices.length; i < n; )\n            {\n                var boneCount = vertices[i++] | 0;\n                bones[bones.length] = boneCount;\n                for (var nn = i + boneCount * 4; i < nn; )\n                {\n                    bones[bones.length] = vertices[i];\n                    weights[weights.length] = vertices[i + 1] * scale;\n                    weights[weights.length] = vertices[i + 2] * scale;\n                    weights[weights.length] = vertices[i + 3];\n                    i += 4;\n                }\n            }\n            mesh.bones = bones;\n            mesh.weights = weights;\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = uvs;\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\")\n                        timeline = new spine.ScaleTimeline(values.length);\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    var x = timelineName == \"flipX\";\n                    var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var field = x ? \"x\" : \"y\";\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[field] || false);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./BoneData\":13,\"./ColorTimeline\":15,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./FlipXTimeline\":22,\"./FlipYTimeline\":23,\"./IkConstraintData\":25,\"./IkConstraintTimeline\":26,\"./RotateTimeline\":29,\"./ScaleTimeline\":30,\"./SkeletonData\":33,\"./Skin\":35,\"./SlotData\":38,\"./TranslateTimeline\":40}],35:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n\n},{\"../SpineUtil\":42}],36:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkinnedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.SkinnedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.skinnedmesh,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, bone, vx, vy, weight;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.SkinnedMeshAttachment;\r\n\r\n\n},{\"../SpineUtil\":42,\"./AttachmentType\":11}],37:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n\n},{\"../SpineUtil\":42}],38:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n\n},{\"../SpineUtil\":42}],39:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n\n},{\"../SpineUtil\":42}],40:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./Curves\":16}],41:[function(require,module,exports){\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.1\r\n *\r\n * Copyright (c) 2013, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable and\r\n * non-transferable license to install, execute and perform the Spine Runtimes\r\n * Software (the \"Software\") solely for internal use. Without the written\r\n * permission of Esoteric Software (typically granted by licensing Spine), you\r\n * may not (a) modify, translate, adapt or otherwise create derivative works,\r\n * improvements of the Software or develop new applications using the Software\r\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\r\n * trademark, patent or other intellectual property or proprietary rights\r\n * notices on or in the Software, including any copy thereof. Redistributions\r\n * in binary or source form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.AnimationStateData = require('./AnimationStateData');\r\nspine.AnimationState = require('./AnimationState');\r\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\r\nspine.Atlas = require('./Atlas');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoneData = require('./BoneData');\r\nspine.Bone = require('./Bone');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.Curves = require('./Curves');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventData = require('./EventData');\r\nspine.Event = require('./Event');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.FlipXTimeline = require('./FlipXTimeline');\r\nspine.FlipYTimeline = require('./FlipYTimeline');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.SkeletonBounds = require('./SkeletonBounds');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.Skeleton = require('./Skeleton');\r\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\r\nspine.Skin = require('./Skin.js');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.SlotData = require('./SlotData');\r\nspine.Slot = require('./Slot');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nmodule.exports = spine;\r\n\n},{\"../SpineUtil\":42,\"./Animation\":2,\"./AnimationState\":3,\"./AnimationStateData\":4,\"./Atlas\":5,\"./AtlasAttachmentParser\":6,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./Bone\":12,\"./BoneData\":13,\"./BoundingBoxAttachment\":14,\"./ColorTimeline\":15,\"./Curves\":16,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./FlipXTimeline\":22,\"./FlipYTimeline\":23,\"./IkConstraint\":24,\"./IkConstraintData\":25,\"./IkConstraintTimeline\":26,\"./MeshAttachment\":27,\"./RegionAttachment\":28,\"./RotateTimeline\":29,\"./ScaleTimeline\":30,\"./Skeleton\":31,\"./SkeletonBounds\":32,\"./SkeletonData\":33,\"./SkeletonJsonParser\":34,\"./Skin.js\":35,\"./SkinnedMeshAttachment\":36,\"./Slot\":37,\"./SlotData\":38,\"./TrackEntry\":39,\"./TranslateTimeline\":40}],42:[function(require,module,exports){\nmodule.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array\r\n};\r\n\r\n\n},{}],43:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n\n    //seminz\n    this.hitArea = new PIXI.Rectangle();\n    this.clickArea = new PIXI.Rectangle();\n    this.runLowerAnimation = this.spineData.findAnimation('run_lower');\n\n    this.shoot_slot = this.skeleton.findSlot('shoot');\n    if(this.shoot_slot === null){\n        this.shoot_slot = this.skeleton.findSlot('weapon_l');\n    }\n\n    var anis = this.spineData.animations;\n    for(var i in anis){\n        var ani = anis[i];\n        this.state.timeScales[ani.name] = 1.0;\n    }\n\n    this.play = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\n//by seminz\nSpine.prototype.setTimeScale = function(aniName, speed) {\n    if(this.state.timeScales[aniName] === undefined) return;\n    this.state.timeScales[aniName] = speed;\n};\n\nSpine.prototype.getCurrentAnimationName = function(index) {\n    var entry = this.state.getCurrent(index);\n    if (!entry)\n        return null;\n    else\n        return entry.animation.name;\n};\n\nSpine.prototype.getCurrentAnimationName = function(index) {\n    var entry = this.state.getCurrent(index);\n    if (!entry)\n        return null;\n    else\n        return entry.animation.name;\n};\n\n//end seminz\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    //seminz\n    if(this.play === false) return;\n    //end seminz\n\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    //seminz\n    if(this.preProcessing) this.preProcessing(dt);\n    //end seminz\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            var bone = slot.bone;\n\n            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n            slotContainer.scale.x = bone.worldScaleX;\n            slotContainer.scale.y = bone.worldScaleY;\n            slotContainer.rotation = -(slot.bone.worldRotation * spine.degRad);\n            if (bone.worldFlipX) {\n                slotContainer.scale.x = -slotContainer.scale.x;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            if (bone.worldFlipY == spine.Bone.yDown) {\n                slotContainer.scale.y = -slotContainer.scale.y;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n\n        }\n        //seminz\n        else if(type === spine.AttachmentType.boundingbox) {\n            if(attachment.name == \"hitarea\") {\n                var x = 0;\n                var y = 0;\n                var vertices = [];\n                vertices.length = 8;\n                attachment.computeWorldVertices(x, y, slot.bone, vertices);\n                var hitArea = JLib.getRectFromPoly(vertices);\n                this.hitArea.x = hitArea.x;\n                this.hitArea.y = hitArea.y\n                this.hitArea.width = hitArea.width;\n                this.hitArea.height = hitArea.height;\n            }\n            if(attachment.name == \"click\") {\n                var x = 0;\n                var y = 0;\n                var vertices = [];\n                vertices.length = 8;\n                attachment.computeWorldVertices(x, y, slot.bone, vertices);\n                var clickArea = JLib.getRectFromPoly(vertices);\n                this.clickArea.x = clickArea.x;\n                this.clickArea.y = clickArea.y\n                this.clickArea.width = clickArea.width;\n                this.clickArea.height = clickArea.height;\n            }\n        }\n        //seminz end\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    this.lastTime = this.lastTime || Date.now();\n    var timeDelta = (Date.now() - this.lastTime) * 0.001;\n    this.lastTime = Date.now();\n\n    this.update(timeDelta);\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nfunction createTextureByRegion(region) {\n    if(0) {\n        var texture = PIXI.utils.TextureCache[region.name];\n        if(texture){\n            return texture;\n        }\n    }\n    var spriteRect = new PIXI.Rectangle(\n        region.x,\n        region.y,\n        region.width,\n        region.height);\n    //region.rotate ? region.height : region.width,\n    //region.rotate ? region.width : region.height);\n\n    //console.log(region);\n\n    var trimmed = false;\n    if(region.originalWidth != region.width || region.originalHeight != region.height) {\n        trimmed = true;\n    }\n    var crop = null;\n    var trim = null;\n    if(trimmed) {\n        var spriteSourceSizeHeight = region.originalHeight - region.offsetY - region.height;\n        crop = spriteRect.clone();\n        trim = new PIXI.Rectangle(region.offsetX, spriteSourceSizeHeight, region.originalWidth, region.originalHeight);\n    }\n    var base_texture = region.page.rendererObject;\n    return new PIXI.Texture(base_texture, spriteRect, crop, trim, region.rotate );\n}\n\n\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    if(0){\n        var baseTexture = descriptor.page.rendererObject;\n        var spriteRect = new PIXI.Rectangle(descriptor.x,\n            descriptor.y,\n            descriptor.rotate ? descriptor.height : descriptor.width,\n            descriptor.rotate ? descriptor.width : descriptor.height);\n        var spriteTexture = new PIXI.Texture(baseTexture, spriteRect);\n    } else {\n        var spriteTexture = createTextureByRegion(descriptor);\n    }\n\n    var sprite = new PIXI.Sprite(spriteTexture);\n    //console.log('CREATE SPRITE', descriptor);\n\n    if(0){\n        var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;\n        sprite.scale.x = attachment.width / descriptor.originalWidth * attachment.scaleX;\n        sprite.scale.y = attachment.height / descriptor.originalHeight * attachment.scaleY;\n        sprite.rotation = baseRotation - (attachment.rotation * spine.degRad);\n        sprite.anchor.x = (0.5 * descriptor.originalWidth - descriptor.offsetX) / descriptor.width;\n        sprite.anchor.y = (0.5 * descriptor.originalHeight - descriptor.offsetY) / descriptor.height;\n        sprite.alpha = attachment.a;\n    } else {\n        sprite.scale.x = attachment.scaleX;\n        sprite.scale.y = attachment.scaleY;\n        sprite.rotation =  -(attachment.rotation * spine.degRad);\n        sprite.anchor.x = (0.5);\n        sprite.anchor.y = (0.5);\n        sprite.alpha = attachment.a;\n    }\n\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\n},{\"../SpineRuntime\":41,\"../loaders/atlasParser\":45}],44:[function(require,module,exports){\n/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n\n},{\"./atlasParser\":45}],45:[function(require,module,exports){\nvar Resource = PIXI.loaders.Resource,\r\n    async = PIXI.utils.async,\r\n    spine = require('../SpineRuntime');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            // create a spine atlas using the loaded text\r\n            var spineAtlas = new spine.Atlas(this.xhr.responseText, baseUrl, res.crossOrigin);\r\n\r\n            // spine animation\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = spineAtlas;\r\n            if (atlasParser.enableCaching)\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n\r\n            // Go through each spineAtlas.pages and wait for page.rendererObject (a baseTexture) to\r\n            // load. Once all loaded, then call the next function.\r\n            async.each(spineAtlas.pages, function (page, done) {\r\n                if (page.rendererObject.hasLoaded) {\r\n                    done();\r\n                }\r\n                else {\r\n                    page.rendererObject.once('loaded', done);\r\n                }\r\n            }, next);\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = true;\r\n\n},{\"../SpineRuntime\":41}],46:[function(require,module,exports){\nmodule.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader')\r\n};\r\n\n},{\"./Loader\":44,\"./atlasParser\":45}]},{},[1])\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\nspine.TrackEntry = require('./TrackEntry');\nspine.AnimationState = function (stateData)\n{\n    //seminz\n    this.timeScales = {};\n    //end seminz\n    this.data = stateData;\n    this.tracks = [];\n    this.events = [];\n};\nspine.AnimationState.prototype = {\n    onStart: null,\n    onEnd: null,\n    onComplete: null,\n    onEvent: null,\n    timeScale: 1,\n    update: function (delta)\n    {\n        delta *= this.timeScale;\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            current.time += delta * current.timeScale;\n            if (current.previous)\n            {\n                var previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n\n            var next = current.next;\n            if (next)\n            {\n                next.time = current.lastTime - next.delay;\n                if (next.time >= 0) this.setCurrent(i, next);\n            } else {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\n            }\n        }\n    },\n    apply: function (skeleton)\n    {\n        skeleton.resetDrawOrder();\n\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            this.events.length = 0;\n\n            var time = current.time;\n            var lastTime = current.lastTime;\n            var endTime = current.endTime;\n            var loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            var previous = current.previous;\n            if (!previous)\n            {\n                if (current.mix == 1)\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\n                else\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\n            } else {\n                var previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                var alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1)\n                {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\n            }\n\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\n            {\n                var event = this.events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\n            {\n                var count = Math.floor(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    },\n    clearTracks: function ()\n    {\n        for (var i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    },\n    clearTrack: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (!current) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n    },\n    _expandToIndex: function (index)\n    {\n        if (index < this.tracks.length) return this.tracks[index];\n        while (index >= this.tracks.length)\n            this.tracks.push(null);\n        return null;\n    },\n    setCurrent: function (index, entry)\n    {\n        var current = this._expandToIndex(index);\n        if (current)\n        {\n            var previous = current.previous;\n            current.previous = null;\n\n            if (current.onEnd) current.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0)\n            {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous && current.mixTime / current.mixDuration < 0.5)\n                    entry.previous = previous;\n                else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    },\n    setAnimationByName: function (trackIndex, animationName, loop)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.setAnimation(trackIndex, animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimation: function (trackIndex, animation, loop)\n    {\n        //seminz\n        this.timeScale = this.timeScales[animation.name];\n        //end seminz\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    },\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.addAnimation(trackIndex, animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (trackIndex, animation, loop, delay)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        var last = this._expandToIndex(trackIndex);\n        if (last)\n        {\n            while (last.next)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0)\n        {\n            if (last)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    },\n    /** May be null. */\n    getCurrent: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n};\nmodule.exports = spine.AnimationState;\n\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\n\r\nspine.Atlas = function (atlasText, baseUrl, crossOrigin)\r\n{\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n\r\n    this.pages = [];\r\n    this.regions = [];\r\n\r\n    this.texturesLoading = 0;\r\n\r\n    var self = this;\r\n    var resolution = PIXI.utils.getResolutionOfUrl(baseUrl);\r\n\r\n    var reader = new spine.AtlasReader(atlasText);\r\n    var tuple = [];\r\n    tuple.length = 4;\r\n    var page = null;\r\n    while (true)\r\n    {\r\n        var line = reader.readLine();\r\n        if (line === null) break;\r\n        line = reader.trim(line);\r\n        if (!line.length)\r\n            page = null;\r\n        else if (!page)\r\n        {\r\n            page = new spine.AtlasPage();\r\n            page.name = line;\r\n\r\n            if (reader.readTuple(tuple) == 2)\r\n            { // size is only optional for an atlas packed with an old TexturePacker.\r\n                page.width = parseInt(tuple[0]);\r\n                page.height = parseInt(tuple[1]);\r\n                reader.readTuple(tuple);\r\n            } else {\r\n                //and I dont want to add support of old format for meshes! we need UVs NOW!\r\n                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n            }\r\n            page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n            reader.readTuple(tuple);\r\n            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n            var direction = reader.readValue();\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            if (direction == \"x\")\r\n                page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"y\")\r\n                page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n            else if (direction == \"xy\")\r\n                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n            page.rendererObject = PIXI.BaseTexture.fromImage(baseUrl + line, crossOrigin);\r\n\r\n            this.pages.push(page);\r\n\r\n        } else {\r\n            var region = new spine.AtlasRegion();\r\n            region.name = line;\r\n            region.page = page;\r\n\r\n            region.rotate = reader.readValue() == \"true\";\r\n\r\n            reader.readTuple(tuple);\r\n            var x = parseInt(tuple[0]);\r\n            var y = parseInt(tuple[1]);\r\n\r\n            reader.readTuple(tuple);\r\n            var width = parseInt(tuple[0]);\r\n            var height = parseInt(tuple[1]);\r\n\r\n            region.u = x / page.width;\r\n            region.v = y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (x + height) / page.width;\r\n                region.v2 = (y + width) / page.height;\r\n            } else {\r\n                region.u2 = (x + width) / page.width;\r\n                region.v2 = (y + height) / page.height;\r\n            }\r\n            region.x = x / resolution;\r\n            region.y = y / resolution;\r\n            region.width = Math.abs(width) / resolution;\r\n            region.height = Math.abs(height) / resolution;\r\n\r\n            if (reader.readTuple(tuple) == 4)\r\n            { // split is optional\r\n                region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                if (reader.readTuple(tuple) == 4)\r\n                { // pad is optional, but only present with splits\r\n                    region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                    reader.readTuple(tuple);\r\n                }\r\n            }\r\n\r\n            region.originalWidth = parseInt(tuple[0]) / resolution;\r\n            region.originalHeight = parseInt(tuple[1]) / resolution;\r\n\r\n            reader.readTuple(tuple);\r\n            region.offsetX = parseInt(tuple[0]) / resolution;\r\n            region.offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n            region.index = parseInt(reader.readValue());\r\n\r\n            this.regions.push(region);\r\n        }\r\n    }\r\n};\r\nspine.Atlas.prototype = {\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.u = region.x / page.width;\r\n            region.v = region.y / page.height;\r\n            if (region.rotate)\r\n            {\r\n                region.u2 = (region.x + region.height) / page.width;\r\n                region.v2 = (region.y + region.width) / page.height;\r\n            } else {\r\n                region.u2 = (region.x + region.width) / page.width;\r\n                region.v2 = (region.y + region.height) / page.height;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.AtlasAttachmentParser = function (atlas)\r\n{\r\n    this.atlas = atlas;\r\n};\r\nspine.AtlasAttachmentParser.prototype = {\r\n    newRegionAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\r\n        var attachment = new spine.RegionAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.MeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newSkinnedMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.SkinnedMeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.regionU = region.u;\r\n        attachment.regionV = region.v;\r\n        attachment.regionU2 = region.u2;\r\n        attachment.regionV2 = region.v2;\r\n        attachment.regionRotate = region.rotate;\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.offsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newBoundingBoxAttachment: function (skin, name)\r\n    {\r\n        return new spine.BoundingBoxAttachment(name);\r\n    }\r\n};\r\nmodule.exports = spine.AtlasAttachmentParser;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    page: null,\r\n    name: null,\r\n    x: 0, y: 0,\r\n    width: 0, height: 0,\r\n    u: 0, v: 0, u2: 0, v2: 0,\r\n    offsetX: 0, offsetY: 0,\r\n    originalWidth: 0, originalHeight: 0,\r\n    index: 0,\r\n    rotate: false,\r\n    splits: null,\r\n    pads: null\r\n};\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = {\r\n    region: 0,\r\n    boundingbox: 1,\r\n    mesh: 2,\r\n    skinnedmesh: 3\r\n};\r\nmodule.exports = spine.AttachmentType;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = function (boneData, skeleton, parent)\r\n{\r\n    this.data = boneData;\r\n    this.skeleton = skeleton;\r\n    this.parent = parent;\r\n    this.setToSetupPose();\r\n};\r\nspine.Bone.yDown = false;\r\nspine.Bone.prototype = {\r\n    x: 0, y: 0,\r\n    rotation: 0, rotationIK: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    flipX: false, flipY: false,\r\n    m00: 0, m01: 0, worldX: 0, // a b x\r\n    m10: 0, m11: 0, worldY: 0, // c d y\r\n    worldRotation: 0,\r\n    worldScaleX: 1, worldScaleY: 1,\r\n    worldFlipX: false, worldFlipY: false,\r\n    updateWorldTransform: function ()\r\n    {\r\n        var parent = this.parent;\r\n        if (parent)\r\n        {\r\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\r\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\r\n            if (this.data.inheritScale)\r\n            {\r\n                this.worldScaleX = parent.worldScaleX * this.scaleX;\r\n                this.worldScaleY = parent.worldScaleY * this.scaleY;\r\n            } else {\r\n                this.worldScaleX = this.scaleX;\r\n                this.worldScaleY = this.scaleY;\r\n            }\r\n            this.worldRotation = this.data.inheritRotation ? (parent.worldRotation + this.rotationIK) : this.rotationIK;\r\n            this.worldFlipX = parent.worldFlipX != this.flipX;\r\n            this.worldFlipY = parent.worldFlipY != this.flipY;\r\n        } else {\r\n            var skeletonFlipX = this.skeleton.flipX, skeletonFlipY = this.skeleton.flipY;\r\n            this.worldX = skeletonFlipX ? -this.x : this.x;\r\n            this.worldY = (skeletonFlipY != spine.Bone.yDown) ? -this.y : this.y;\r\n            this.worldScaleX = this.scaleX;\r\n            this.worldScaleY = this.scaleY;\r\n            this.worldRotation = this.rotationIK;\r\n            this.worldFlipX = skeletonFlipX != this.flipX;\r\n            this.worldFlipY = skeletonFlipY != this.flipY;\r\n        }\r\n        var radians = this.worldRotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        if (this.worldFlipX)\r\n        {\r\n            this.m00 = -cos * this.worldScaleX;\r\n            this.m01 = sin * this.worldScaleY;\r\n        } else {\r\n            this.m00 = cos * this.worldScaleX;\r\n            this.m01 = -sin * this.worldScaleY;\r\n        }\r\n        if (this.worldFlipY != spine.Bone.yDown)\r\n        {\r\n            this.m10 = -sin * this.worldScaleX;\r\n            this.m11 = -cos * this.worldScaleY;\r\n        } else {\r\n            this.m10 = sin * this.worldScaleX;\r\n            this.m11 = cos * this.worldScaleY;\r\n        }\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.rotationIK = this.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.flipX = data.flipX;\r\n        this.flipY = data.flipY;\r\n    },\r\n    worldToLocal: function (world)\r\n    {\r\n        var dx = world[0] - this.worldX, dy = world[1] - this.worldY;\r\n        var m00 = this.m00, m10 = this.m10, m01 = this.m01, m11 = this.m11;\r\n        if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown))\r\n        {\r\n            m00 = -m00;\r\n            m11 = -m11;\r\n        }\r\n        var invDet = 1 / (m00 * m11 - m01 * m10);\r\n        world[0] = dx * m00 * invDet - dy * m01 * invDet;\r\n        world[1] = dy * m11 * invDet - dx * m10 * invDet;\r\n    },\r\n    localToWorld: function (local)\r\n    {\r\n        var localX = local[0], localY = local[1];\r\n        local[0] = localX * this.m00 + localY * this.m01 + this.worldX;\r\n        local[1] = localX * this.m10 + localY * this.m11 + this.worldY;\r\n    }\r\n};\r\nmodule.exports = spine.Bone;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.BoneData = function (name, parent)\r\n{\r\n    this.name = name;\r\n    this.parent = parent;\r\n};\r\nspine.BoneData.prototype = {\r\n    length: 0,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    inheritScale: true,\r\n    inheritRotation: true,\r\n    flipX: false, flipY: false\r\n};\r\nmodule.exports = spine.BoneData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (slot.attachment != this.attachment) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipXTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipXTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipX = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipXTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FlipYTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, flip, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.FlipYTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, flip)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\r\n        if (frames[frameIndex] < lastTime) return;\r\n        skeleton.bones[this.boneIndex].flipY = frames[frameIndex + 1] != 0;\r\n    }\r\n};\r\nmodule.exports = spine.FlipYTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.IkConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.mix = data.mix;\r\n    this.bendDirection = data.bendDirection;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = data.bones.length; i < n; i++)\r\n        this.bones.push(skeleton.findBone(data.bones[i].name));\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\nspine.IkConstraint.prototype = {\r\n    apply: function ()\r\n    {\r\n        var target = this.target;\r\n        var bones = this.bones;\r\n        switch (bones.length)\r\n        {\r\n        case 1:\r\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n};\r\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n * coordinate system. */\r\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\r\n{\r\n    var parentRotation = (!bone.data.inheritRotation || !bone.parent) ? 0 : bone.parent.worldRotation;\r\n    var rotation = bone.rotation;\r\n    // worldY and targetY sign depends on global constant spine.Bone.yDown\r\n    var rotationIK = (spine.Bone.yDown?-spine.radDeg:spine.radDeg)* Math.atan2(targetY - bone.worldY, targetX - bone.worldX) - parentRotation;\r\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\r\n};\r\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n * target is specified in the world coordinate system.\r\n * @param child Any descendant bone of the parent. */\r\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDirection, alpha)\r\n{\r\n    var childRotation = child.rotation, parentRotation = parent.rotation;\r\n    if (!alpha)\r\n    {\r\n        child.rotationIK = childRotation;\r\n        parent.rotationIK = parentRotation;\r\n        return;\r\n    }\r\n    var positionX, positionY, tempPosition = spine.temp;\r\n    var parentParent = parent.parent;\r\n    if (parentParent)\r\n    {\r\n        tempPosition[0] = targetX;\r\n        tempPosition[1] = targetY;\r\n        parentParent.worldToLocal(tempPosition);\r\n        targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;\r\n        targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;\r\n    } else {\r\n        targetX -= parent.x;\r\n        targetY -= parent.y;\r\n    }\r\n    if (child.parent == parent)\r\n    {\r\n        positionX = child.x;\r\n        positionY = child.y;\r\n    } else {\r\n        tempPosition[0] = child.x;\r\n        tempPosition[1] = child.y;\r\n        child.parent.localToWorld(tempPosition);\r\n        parent.worldToLocal(tempPosition);\r\n        positionX = tempPosition[0];\r\n        positionY = tempPosition[1];\r\n    }\r\n    var childX = positionX * parent.worldScaleX, childY = positionY * parent.worldScaleY;\r\n    var offset = Math.atan2(childY, childX);\r\n    var len1 = Math.sqrt(childX * childX + childY * childY), len2 = child.data.length * child.worldScaleX;\r\n    // Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/\r\n    var cosDenom = 2 * len1 * len2;\r\n    if (cosDenom < 0.0001)\r\n    {\r\n        child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;\r\n        return;\r\n    }\r\n    var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;\r\n    if (cos < -1)\r\n        cos = -1;\r\n    else if (cos > 1)\r\n        cos = 1;\r\n    var childAngle = Math.acos(cos) * bendDirection;\r\n    var adjacent = len1 + len2 * cos, opposite = len2 * Math.sin(childAngle);\r\n    var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);\r\n    var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    parent.rotationIK = parentRotation + rotation * alpha;\r\n    rotation = (childAngle + offset) * spine.radDeg - childRotation;\r\n    if (rotation > 180)\r\n        rotation -= 360;\r\n    else if (rotation < -180) //\r\n        rotation += 360;\r\n    child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;\r\n};\r\nmodule.exports = spine.IkConstraint;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.MeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.MeshAttachment.prototype = {\r\n    type: spine.AttachmentType.mesh,\r\n    vertices: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function ()\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var bone = slot.bone;\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var vertices = this.vertices;\r\n        var verticesCount = vertices.length;\r\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\r\n        for (var i = 0; i < verticesCount; i += 2)\r\n        {\r\n            var vx = vertices[i];\r\n            var vy = vertices[i + 1];\r\n            worldVertices[i] = vx * m00 + vy * m01 + x;\r\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.MeshAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.RegionAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.offset = [];\r\n    this.offset.length = 8;\r\n    this.uvs = [];\r\n    this.uvs.length = 8;\r\n};\r\nspine.RegionAttachment.prototype = {\r\n    type: spine.AttachmentType.region,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    width: 0, height: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    setUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var uvs = this.uvs;\r\n        if (rotate)\r\n        {\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v2;\r\n            uvs[4/*X3*/] = u;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v;\r\n            uvs[0/*X1*/] = u2;\r\n            uvs[1/*Y1*/] = v2;\r\n        } else {\r\n            uvs[0/*X1*/] = u;\r\n            uvs[1/*Y1*/] = v2;\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v;\r\n            uvs[4/*X3*/] = u2;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v2;\r\n        }\r\n    },\r\n    updateOffset: function ()\r\n    {\r\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\r\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\r\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\r\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\r\n        var localX2 = localX + this.regionWidth * regionScaleX;\r\n        var localY2 = localY + this.regionHeight * regionScaleY;\r\n        var radians = this.rotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        var localXCos = localX * cos + this.x;\r\n        var localXSin = localX * sin;\r\n        var localYCos = localY * cos + this.y;\r\n        var localYSin = localY * sin;\r\n        var localX2Cos = localX2 * cos + this.x;\r\n        var localX2Sin = localX2 * sin;\r\n        var localY2Cos = localY2 * cos + this.y;\r\n        var localY2Sin = localY2 * sin;\r\n        var offset = this.offset;\r\n        offset[0/*X1*/] = localXCos - localYSin;\r\n        offset[1/*Y1*/] = localYCos + localXSin;\r\n        offset[2/*X2*/] = localXCos - localY2Sin;\r\n        offset[3/*Y2*/] = localY2Cos + localXSin;\r\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\r\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\r\n        offset[6/*X4*/] = localX2Cos - localYSin;\r\n        offset[7/*Y4*/] = localYCos + localX2Sin;\r\n    },\r\n    computeVertices: function (x, y, bone, vertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;\r\n        var offset = this.offset;\r\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\r\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\r\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\r\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\r\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\r\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\r\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\r\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\r\n    }\r\n};\r\nmodule.exports = spine.RegionAttachment;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = require('./Bone');\r\nspine.Slot = require('./Slot');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.Skeleton = function (skeletonData)\r\n{\r\n    this.data = skeletonData;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\r\n    {\r\n        var boneData = skeletonData.bones[i];\r\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\r\n        this.bones.push(new spine.Bone(boneData, this, parent));\r\n    }\r\n\r\n    this.slots = [];\r\n    this.drawOrder = [];\r\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\r\n    {\r\n        var slotData = skeletonData.slots[i];\r\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\r\n        var slot = new spine.Slot(slotData, bone);\r\n        this.slots.push(slot);\r\n        this.drawOrder.push(i);\r\n    }\r\n\r\n    this.ikConstraints = [];\r\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\r\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\r\n\r\n    this.boneCache = [];\r\n    this.updateCache();\r\n};\r\nspine.Skeleton.prototype = {\r\n    x: 0, y: 0,\r\n    skin: null,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    time: 0,\r\n    flipX: false, flipY: false,\r\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\r\n    updateCache: function ()\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        var ikConstraintsCount = ikConstraints.length;\r\n\r\n        var arrayCount = ikConstraintsCount + 1;\r\n        var boneCache = this.boneCache;\r\n        if (boneCache.length > arrayCount) boneCache.length = arrayCount;\r\n        for (var i = 0, n = boneCache.length; i < n; i++)\r\n            boneCache[i].length = 0;\r\n        while (boneCache.length < arrayCount)\r\n            boneCache[boneCache.length] = [];\r\n\r\n        var nonIkBones = boneCache[0];\r\n        var bones = this.bones;\r\n\r\n        outer:\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            var current = bone;\r\n            do {\r\n                for (var ii = 0; ii < ikConstraintsCount; ii++)\r\n                {\r\n                    var ikConstraint = ikConstraints[ii];\r\n                    var parent = ikConstraint.bones[0];\r\n                    var child= ikConstraint.bones[ikConstraint.bones.length - 1];\r\n                    while (true)\r\n                    {\r\n                        if (current == child)\r\n                        {\r\n                            boneCache[ii].push(bone);\r\n                            boneCache[ii + 1].push(bone);\r\n                            continue outer;\r\n                        }\r\n                        if (child == parent) break;\r\n                        child = child.parent;\r\n                    }\r\n                }\r\n                current = current.parent;\r\n            } while (current);\r\n            nonIkBones[nonIkBones.length] = bone;\r\n        }\r\n    },\r\n    /** Updates the world transform for each bone. */\r\n    updateWorldTransform: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            bone.rotationIK = bone.rotation;\r\n        }\r\n        var i = 0, last = this.boneCache.length - 1;\r\n        while (true)\r\n        {\r\n            var cacheBones = this.boneCache[i];\r\n            for (var ii = 0, nn = cacheBones.length; ii < nn; ii++)\r\n                cacheBones[ii].updateWorldTransform();\r\n            if (i == last) break;\r\n            this.ikConstraints[i].apply();\r\n            i++;\r\n        }\r\n    },\r\n    /** Sets the bones and slots to their setup pose values. */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    },\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n        {\r\n            var ikConstraint = ikConstraints[i];\r\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\r\n            ikConstraint.mix = ikConstraint.data.mix;\r\n        }\r\n    },\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            slots[i].setToSetupPose(i);\r\n        }\r\n\r\n        this.resetDrawOrder();\r\n    },\r\n    /** @return May return null. */\r\n    getRootBone: function ()\r\n    {\r\n        return this.bones.length ? this.bones[0] : null;\r\n    },\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return slots[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    },\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skin = this.data.findSkin(skinName);\r\n        if (!skin) throw \"Skin not found: \" + skinName;\r\n        this.setSkin(skin);\r\n    },\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin: function (newSkin)\r\n    {\r\n        if (newSkin)\r\n        {\r\n            if (this.skin)\r\n                newSkin._attachAll(this, this.skin);\r\n            else\r\n            {\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                {\r\n                    var slot = slots[i];\r\n                    var name = slot.data.attachmentName;\r\n                    if (name)\r\n                    {\r\n                        var attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotName: function (slotName, attachmentName)\r\n    {\r\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\r\n    {\r\n        if (this.skin)\r\n        {\r\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    },\r\n    /** @param attachmentName May be null. */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slot = slots[i];\r\n            if (slot.data.name == slotName)\r\n            {\r\n                var attachment = null;\r\n                if (attachmentName)\r\n                {\r\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\r\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw \"Slot not found: \" + slotName;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (ikConstraintName)\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n            if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];\r\n        return null;\r\n    },\r\n    update: function (delta)\r\n    {\r\n        this.time += delta;\r\n    },\r\n    resetDrawOrder: function () {\r\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\r\n        {\r\n            this.drawOrder[i] = i;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skeleton;\r\n\r\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SkeletonData = function ()\r\n{\r\n    this.bones = [];\r\n    this.slots = [];\r\n    this.skins = [];\r\n    this.events = [];\r\n    this.animations = [];\r\n    this.ikConstraints = [];\r\n};\r\nspine.SkeletonData.prototype = {\r\n    name: null,\r\n    defaultSkin: null,\r\n    width: 0, height: 0,\r\n    version: null, hash: null,\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            if (slots[i].name == slotName) return this.slots[i];\r\n        }\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSkin: function (skinName)\r\n    {\r\n        var skins = this.skins;\r\n        for (var i = 0, n = skins.length; i < n; i++)\r\n            if (skins[i].name == skinName) return skins[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findEvent: function (eventName)\r\n    {\r\n        var events = this.events;\r\n        for (var i = 0, n = events.length; i < n; i++)\r\n            if (events[i].name == eventName) return events[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findAnimation: function (animationName)\r\n    {\r\n        var animations = this.animations;\r\n        for (var i = 0, n = animations.length; i < n; i++)\r\n            if (animations[i].name == animationName) return animations[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (ikConstraintName)\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n            if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];\r\n        return null;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonData;\r\n\r\n","var spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.FlipXTimeline = require('./FlipXTimeline');\nspine.FlipYTimeline = require('./FlipYTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    this.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw \"IK bone not found: \" + bones[ii];\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw \"Target bone not found: \" + ikMap[\"target\"];\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n            //seminz\n            if(!slotData.blendMode) slotData.blendMode = slotMap[\"additive\"]?PIXI.BLEND_MODES.ADD:PIXI.BLEND_MODES.NORMAL;\n            //end seminz\n\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.mesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.skinnedmesh)\n        {\n            var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n\n            var uvs = this.getFloatArray(map, \"uvs\", 1);\n            var vertices = this.getFloatArray(map, \"vertices\", 1);\n            var weights = [];\n            var bones = [];\n            for (var i = 0, n = vertices.length; i < n; )\n            {\n                var boneCount = vertices[i++] | 0;\n                bones[bones.length] = boneCount;\n                for (var nn = i + boneCount * 4; i < nn; )\n                {\n                    bones[bones.length] = vertices[i];\n                    weights[weights.length] = vertices[i + 1] * scale;\n                    weights[weights.length] = vertices[i + 2] * scale;\n                    weights[weights.length] = vertices[i + 3];\n                    i += 4;\n                }\n            }\n            mesh.bones = bones;\n            mesh.weights = weights;\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = uvs;\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\")\n                        timeline = new spine.ScaleTimeline(values.length);\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    var x = timelineName == \"flipX\";\n                    var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var field = x ? \"x\" : \"y\";\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[field] || false);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkinnedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.SkinnedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.skinnedmesh,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        if (this.regionRotate)\r\n        {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\r\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < n; i += 2)\r\n            {\r\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\r\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\r\n            }\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, bone, vx, vy, weight;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    bone = skeletonBones[bones[v]];\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\r\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.SkinnedMeshAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.1\r\n *\r\n * Copyright (c) 2013, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable and\r\n * non-transferable license to install, execute and perform the Spine Runtimes\r\n * Software (the \"Software\") solely for internal use. Without the written\r\n * permission of Esoteric Software (typically granted by licensing Spine), you\r\n * may not (a) modify, translate, adapt or otherwise create derivative works,\r\n * improvements of the Software or develop new applications using the Software\r\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\r\n * trademark, patent or other intellectual property or proprietary rights\r\n * notices on or in the Software, including any copy thereof. Redistributions\r\n * in binary or source form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.AnimationStateData = require('./AnimationStateData');\r\nspine.AnimationState = require('./AnimationState');\r\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\r\nspine.Atlas = require('./Atlas');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoneData = require('./BoneData');\r\nspine.Bone = require('./Bone');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.Curves = require('./Curves');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventData = require('./EventData');\r\nspine.Event = require('./Event');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.FlipXTimeline = require('./FlipXTimeline');\r\nspine.FlipYTimeline = require('./FlipYTimeline');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.SkeletonBounds = require('./SkeletonBounds');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.Skeleton = require('./Skeleton');\r\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\r\nspine.Skin = require('./Skin.js');\r\nspine.SkinnedMeshAttachment = require('./SkinnedMeshAttachment');\r\nspine.SlotData = require('./SlotData');\r\nspine.Slot = require('./Slot');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nmodule.exports = spine;\r\n","module.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array\r\n};\r\n\r\n","var spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n\n    //seminz\n    this.hitArea = new PIXI.Rectangle();\n    this.clickArea = new PIXI.Rectangle();\n    this.runLowerAnimation = this.spineData.findAnimation('run_lower');\n\n    this.shoot_slot = this.skeleton.findSlot('shoot');\n    if(this.shoot_slot === null){\n        this.shoot_slot = this.skeleton.findSlot('weapon_l');\n    }\n\n    var anis = this.spineData.animations;\n    for(var i in anis){\n        var ani = anis[i];\n        this.state.timeScales[ani.name] = 1.0;\n    }\n\n    this.play = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\n//by seminz\nSpine.prototype.setTimeScale = function(aniName, speed) {\n    if(this.state.timeScales[aniName] === undefined) return;\n    this.state.timeScales[aniName] = speed;\n};\n\nSpine.prototype.getCurrentAnimationName = function(index) {\n    var entry = this.state.getCurrent(index);\n    if (!entry)\n        return null;\n    else\n        return entry.animation.name;\n};\n\nSpine.prototype.getCurrentAnimationName = function(index) {\n    var entry = this.state.getCurrent(index);\n    if (!entry)\n        return null;\n    else\n        return entry.animation.name;\n};\n\n//end seminz\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    //seminz\n    if(this.play === false) return;\n    //end seminz\n\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    //seminz\n    if(this.preProcessing) this.preProcessing(dt);\n    //end seminz\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            var bone = slot.bone;\n\n            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n            slotContainer.scale.x = bone.worldScaleX;\n            slotContainer.scale.y = bone.worldScaleY;\n            slotContainer.rotation = -(slot.bone.worldRotation * spine.degRad);\n            if (bone.worldFlipX) {\n                slotContainer.scale.x = -slotContainer.scale.x;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            if (bone.worldFlipY == spine.Bone.yDown) {\n                slotContainer.scale.y = -slotContainer.scale.y;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n\n        }\n        //seminz\n        else if(type === spine.AttachmentType.boundingbox) {\n            if(attachment.name == \"hitarea\") {\n                var x = 0;\n                var y = 0;\n                var vertices = [];\n                vertices.length = 8;\n                attachment.computeWorldVertices(x, y, slot.bone, vertices);\n                var hitArea = JLib.getRectFromPoly(vertices);\n                this.hitArea.x = hitArea.x;\n                this.hitArea.y = hitArea.y\n                this.hitArea.width = hitArea.width;\n                this.hitArea.height = hitArea.height;\n            }\n            if(attachment.name == \"click\") {\n                var x = 0;\n                var y = 0;\n                var vertices = [];\n                vertices.length = 8;\n                attachment.computeWorldVertices(x, y, slot.bone, vertices);\n                var clickArea = JLib.getRectFromPoly(vertices);\n                this.clickArea.x = clickArea.x;\n                this.clickArea.y = clickArea.y\n                this.clickArea.width = clickArea.width;\n                this.clickArea.height = clickArea.height;\n            }\n        }\n        //seminz end\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    this.lastTime = this.lastTime || Date.now();\n    var timeDelta = (Date.now() - this.lastTime) * 0.001;\n    this.lastTime = Date.now();\n\n    this.update(timeDelta);\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nfunction createTextureByRegion(region) {\n    if(0) {\n        var texture = PIXI.utils.TextureCache[region.name];\n        if(texture){\n            return texture;\n        }\n    }\n    var spriteRect = new PIXI.Rectangle(\n        region.x,\n        region.y,\n        region.width,\n        region.height);\n    //region.rotate ? region.height : region.width,\n    //region.rotate ? region.width : region.height);\n\n    //console.log(region);\n\n    var trimmed = false;\n    if(region.originalWidth != region.width || region.originalHeight != region.height) {\n        trimmed = true;\n    }\n    var crop = null;\n    var trim = null;\n    if(trimmed) {\n        var spriteSourceSizeHeight = region.originalHeight - region.offsetY - region.height;\n        crop = spriteRect.clone();\n        trim = new PIXI.Rectangle(region.offsetX, spriteSourceSizeHeight, region.originalWidth, region.originalHeight);\n    }\n    var base_texture = region.page.rendererObject;\n    return new PIXI.Texture(base_texture, spriteRect, crop, trim, region.rotate );\n}\n\n\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    if(0){\n        var baseTexture = descriptor.page.rendererObject;\n        var spriteRect = new PIXI.Rectangle(descriptor.x,\n            descriptor.y,\n            descriptor.rotate ? descriptor.height : descriptor.width,\n            descriptor.rotate ? descriptor.width : descriptor.height);\n        var spriteTexture = new PIXI.Texture(baseTexture, spriteRect);\n    } else {\n        var spriteTexture = createTextureByRegion(descriptor);\n    }\n\n    var sprite = new PIXI.Sprite(spriteTexture);\n    //console.log('CREATE SPRITE', descriptor);\n\n    if(0){\n        var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;\n        sprite.scale.x = attachment.width / descriptor.originalWidth * attachment.scaleX;\n        sprite.scale.y = attachment.height / descriptor.originalHeight * attachment.scaleY;\n        sprite.rotation = baseRotation - (attachment.rotation * spine.degRad);\n        sprite.anchor.x = (0.5 * descriptor.originalWidth - descriptor.offsetX) / descriptor.width;\n        sprite.anchor.y = (0.5 * descriptor.originalHeight - descriptor.offsetY) / descriptor.height;\n        sprite.alpha = attachment.a;\n    } else {\n        sprite.scale.x = attachment.scaleX;\n        sprite.scale.y = attachment.scaleY;\n        sprite.rotation =  -(attachment.rotation * spine.degRad);\n        sprite.anchor.x = (0.5);\n        sprite.anchor.y = (0.5);\n        sprite.alpha = attachment.a;\n    }\n\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\r\n    async = PIXI.utils.async,\r\n    spine = require('../SpineRuntime');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            // create a spine atlas using the loaded text\r\n            var spineAtlas = new spine.Atlas(this.xhr.responseText, baseUrl, res.crossOrigin);\r\n\r\n            // spine animation\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = spineAtlas;\r\n            if (atlasParser.enableCaching)\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n\r\n            // Go through each spineAtlas.pages and wait for page.rendererObject (a baseTexture) to\r\n            // load. Once all loaded, then call the next function.\r\n            async.each(spineAtlas.pages, function (page, done) {\r\n                if (page.rendererObject.hasLoaded) {\r\n                    done();\r\n                }\r\n                else {\r\n                    page.rendererObject.once('loaded', done);\r\n                }\r\n            }, next);\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = true;\r\n","module.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader')\r\n};\r\n"],"sourceRoot":"./"}